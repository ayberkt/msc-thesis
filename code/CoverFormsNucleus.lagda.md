```
{-# OPTIONS --cubical --safe #-}

module CoverFormsNucleus where

open import Basis          hiding (A)
open import Poset          renaming (IsDownwardClosed to IsDownwardClosed‚Ä≤)
open import Frame
open import HITCoverage
open import Nucleus        using  (IsNuclear; Nucleus; nuclear-fixed-point-frame; idem)
open import Family         using  (Sub; _‚äö_; _‚Ç¨_; _Œµ_; index)
open import Truncation     renaming (squash to squash‚Ä≤)
open import Data.Bool      using    (Bool; true; false)
open import Powerset
open import FormalTopology renaming (pos to pos‚Ä≤)
open import PowFamEquivalence
```

We use an anonymous module that takes some formal topology `F` as a parameter to reduce
parameter-passing.

```
module NucleusFrom (F : FormalTopology ‚Ñì‚ÇÄ ‚Ñì‚ÇÄ) where
```

We refer to the underlying poset of `F` as `P` and the frame of downwards-closed subsets
of `P` as `F‚Üì`. `sim` and `mono` refer to the simulation and monotonicity properties of
`F`.

```
  private
    D       = œÄ‚ÇÄ F
    P       = pos‚Ä≤ (œÄ‚ÇÄ F)
    ùîâ       = ‚à£ P ‚à£‚Çö
    F‚Üì      = downward-subset-frame P
    P‚Üì      = pos F‚Üì
    sim     = œÄ‚ÇÅ F
    mono    = œÄ‚ÇÅ D
    _‚äë_     = Œª (x y : stage D) ‚Üí x ‚äë[ P ] y is-true

  open Test (stage D) _‚äë_ (exp D) (outcome D) (next D) (œÄ‚ÇÅ mono) sim public
```

Now, we define the *covering nucleus* which we denote by `ùïõ`. At its heart, this is
nothing but the map `U ‚Ü¶ - <| U`.

```
  ùïõ : ‚à£ F‚Üì ‚à£F ‚Üí ‚à£ F‚Üì ‚à£F
  ùïõ (U , U-down) = U‚ÇÄ , Œª _ _ ‚Üí down-closed
    where
      -- This is not  h-propositional unless we force it to be using the HIT definition.
      U‚ÇÄ : stage D ‚Üí hProp ‚Ñì‚ÇÄ
      U‚ÇÄ = Œª a ‚Üí a <| (_is-true ‚àò U) , <|-prop a (_is-true ‚àò U)

      down-closed : IsDownwardClosed (Œª - ‚Üí - <| (_is-true ‚àò U))
      down-closed aŒµU‚ÇÅ a‚ÇÄ‚äëa = lem1 (U-down _ _) a‚ÇÄ‚äëa aŒµU‚ÇÅ

  _<<_ : ‚à£ F‚Üì ‚à£F ‚Üí ‚à£ F‚Üì ‚à£F ‚Üí hProp ‚Ñì‚ÇÄ
  x << y = x ‚äë[ pos F‚Üì ] y

  ‚óÄ-antisym = ‚äë[ pos F‚Üì ]-antisym

  ùïõ-nuclear : IsNuclear F‚Üì ùïõ
  ùïõ-nuclear = N‚ÇÄ , N‚ÇÅ , N‚ÇÇ
    where
      -- We reason by antisymmetry and prove in (d) ùïõ (a‚ÇÄ ‚äì a‚ÇÅ) ‚äë (ùïõ a‚ÇÄ) ‚äì (ùïõ a‚ÇÅ) and
      -- in (u) (ùïõ a‚ÇÄ) ‚äì (ùïõ a‚ÇÅ) ‚äë ùïõ (a‚ÇÄ ‚äì a‚ÇÅ).
      N‚ÇÄ : (a‚ÇÄ a‚ÇÅ : ‚à£ F‚Üì ‚à£F) ‚Üí ùïõ (a‚ÇÄ ‚äì[ F‚Üì ] a‚ÇÅ) ‚â° (ùïõ a‚ÇÄ) ‚äì[ F‚Üì ] (ùïõ a‚ÇÅ)
      N‚ÇÄ ùïå@(U , U-down) ùïç@(V , V-down) =
        ‚óÄ-antisym (ùïõ (ùïå ‚äì[ F‚Üì ] ùïç)) (ùïõ ùïå ‚äì[ F‚Üì ] ùïõ ùïç) d u
        where
          U‚Ä≤ = _is-true ‚àò U
          V‚Ä≤ = _is-true ‚àò V

          U-down‚Ä≤ : IsDownwardClosed (_is-true ‚àò U)
          U-down‚Ä≤ = U-down _ _

          V-down‚Ä≤ : IsDownwardClosed (_is-true ‚àò V)
          V-down‚Ä≤ = V-down _ _

          d : ùïõ (ùïå ‚äì[ F‚Üì ] ùïç) << (ùïõ ùïå ‚äì[ F‚Üì ] ùïõ ùïç) is-true
          d a (dir p)        = dir (œÄ‚ÇÄ p) , dir (œÄ‚ÇÅ p)
          d a (branch b f)   = branch b (œÄ‚ÇÄ ‚àò IH) , branch b (œÄ‚ÇÅ ‚àò IH)
            where
              IH : (c : outcome D b) ‚Üí œÄ‚ÇÄ (ùïõ ùïå ‚äì[ F‚Üì ] ùïõ ùïç) (next D c) is-true
              IH c = d (next D c) (f c)
          d a (squash p q i) = squash (œÄ‚ÇÄ IH‚ÇÄ) (œÄ‚ÇÄ IH‚ÇÅ) i , squash (œÄ‚ÇÅ IH‚ÇÄ) (œÄ‚ÇÅ IH‚ÇÅ) i
            where
              IH‚ÇÄ = d a p
              IH‚ÇÅ = d a q

          u : (ùïõ ùïå ‚äì[ F‚Üì ] ùïõ ùïç) << ùïõ (ùïå ‚äì[ F‚Üì ] ùïç) is-true
          u a p = lem3 U‚Ä≤ V‚Ä≤ U-down‚Ä≤ V-down‚Ä≤ a a (‚äë[ P ]-refl a) (œÄ‚ÇÄ p) (œÄ‚ÇÅ p)

      N‚ÇÅ : (ùïå : ‚à£ F‚Üì ‚à£F) ‚Üí ùïå << (ùïõ ùïå) is-true
      N‚ÇÅ ùïå@(U , U-down) a‚ÇÄ p = lem1 (U-down _ _) (‚äë[ P ]-refl a‚ÇÄ) (dir p)

      N‚ÇÇ : (a : ‚à£ F‚Üì ‚à£F) ‚Üí ùïõ (ùïõ a) << (ùïõ a) is-true
      N‚ÇÇ ùïå@(U , U-down) a‚Ä≤ p = lem4 a‚Ä≤ (Œª a ‚Üí œÄ‚ÇÄ (ùïõ ùïå) a is-true) U‚Ä≤ p (Œª _ q ‚Üí q)
        where
          U‚Ä≤ = _is-true ‚àò U
```

We denote by `L` the frame of fixed points for `ùïõ`.

```
  L : Frame (suc ‚Ñì‚ÇÄ) ‚Ñì‚ÇÄ ‚Ñì‚ÇÄ
  L = nuclear-fixed-point-frame F‚Üì (ùïõ , ùïõ-nuclear)

  ‚¶Ö_‚¶Ü : ‚à£ L ‚à£F ‚Üí ùí´ ‚à£ P ‚à£‚Çö
  ‚¶Ö ((U , _) , _) ‚¶Ü = U
```

Given some `x` in `F`, we define a map taking `x` to its *downwards-closure*.

```

  ‚Üì-clos : stage D ‚Üí ‚à£ F‚Üì ‚à£F
  ‚Üì-clos x = x‚Üì , down-DC
    where
      x‚Üì = Œª y ‚Üí y ‚äë[ P ] x
      down-DC : IsDownwardClosed‚Ä≤ P x‚Üì is-true
      down-DC z y z‚äëx y‚äëz = ‚äë[ P ]-trans y z x y‚äëz z‚äëx

  x‚óÄx‚Üì : (x : stage D) ‚Üí x <| (Œª - ‚Üí - ‚äë[ P ] x is-true)
  x‚óÄx‚Üì x = dir (‚äë[ P ]-refl x)
```

By composing this with the covering nucleus, we define a map `e` from `F` to `F‚Üì`.

```
  e : stage D ‚Üí ‚à£ F‚Üì ‚à£F
  e z = (Œª a ‚Üí (a <| (_is-true ‚àò (œÄ‚ÇÄ (‚Üì-clos z)))) , squash) , NTS
    where
      NTS : IsDownwardClosed‚Ä≤ P (Œª a ‚Üí (a <| (Œª - ‚Üí - ‚äë[ P ] z is-true)) , squash) is-true
      NTS x y p q = lem1 (Œª p q ‚Üí ‚äë[ P ]-trans _ _ z q p) q p
```

We can further refine the codomain of `e` to `L`. In other words, we can prove that `j (e
x) = e x` for every `x`. We call the version `e` with the refined codomain `Œ∑`.

```
  fixing : (x : stage D) ‚Üí ùïõ (e x) ‚â° e x
  fixing x = ‚äë[ P‚Üì ]-antisym (ùïõ (e x)) (e x) NTS up
    where
      NTS : ‚àÄ y ‚Üí œÄ‚ÇÄ (ùïõ (e x)) y is-true ‚Üí œÄ‚ÇÄ (e x) y is-true
      NTS y (dir p)        = p
      NTS y (branch b f)   = branch b (Œª c ‚Üí NTS (next D c) (f c))
      NTS y (squash p q i) = squash (NTS y p) (NTS y q) i
      up : e x ‚äë[ P‚Üì ] ùïõ (e x) is-true
      up = œÄ‚ÇÄ (œÄ‚ÇÅ ùïõ-nuclear) (e x)

  Œ∑ : stage (œÄ‚ÇÄ F) ‚Üí ‚à£ L ‚à£F
  Œ∑ x = (e x) , (fixing x)
```

Furthermore, `Œ∑` is a monotonic map.

```
  Œ∑m : P ‚îÄm‚Üí pos L
  Œ∑m = Œ∑ , Œ∑-mono
    where
      Œ∑-mono : IsMonotonic P (pos L) Œ∑
      Œ∑-mono x y x‚äëy a (dir p)        = dir (‚äë[ P ]-trans a x y p x‚äëy)
      Œ∑-mono x y x‚äëy a (branch b f)   = branch b (Œª c ‚Üí Œ∑-mono x y x‚äëy (next D c) (f c))
      Œ∑-mono x y x‚äëy a (squash p q i) = squash (Œ∑-mono x y x‚äëy a p) (Œ∑-mono x y x‚äëy a q) i
```
