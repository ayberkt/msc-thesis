\chapter{Foundations}\label{chap:foundations}

We present in this chapter the basics of univalent type theory. We assume that the reader
is familiar with standard (intensional) type theory and refrain from presenting the formal
calculus from scratch. For this, the reader is referred to Appendix A of the HoTT
Book~\cite{hottbook}. Instead, we focus on the fundamental notions and theorems of
univalent type theory.

Our presentation in this chapter has been heavily influenced by three resources: (1) the
HoTT Book~\cite{hottbook}, (2) Martín Escardó's introductory exposition of HoTT/UF in
\veragda{}~\cite{escardo-uf-intro}, and (3) the \texttt{cubical} library of
\veragda{}~\cite{agda-cubical}.

\section{Formal vs.~informal mathematics}

Our goal in this thesis is to use type theory in an informal way, much like how set theory
is frequently used without committing to a specific one of its implementations. Indeed,
the work to be presented is the \emph{informalisation} of a completely formalised
development, for which the formal system of choice is Cubical Type Theory
(CTT)~\cite{CCHM, cubical-agda}. However, CTT is just one specific instance of a univalent
foundation and therefore its details will not concern us in this thesis. We will instead
abstract over the implementation, and use univalent type theory as a practical
foundation~\cite{PFOM} whose formal details we will leave unspecified. The reader
interested in the full details of the formal development can find the \veragda{}
formalisation in Appendix \ref{app:agda-form}

To keep the informal presentation precise, we will closely follow the notational
conventions of the HoTT Book~\cite{hottbook}, as explained in Section~I.1. Following the
HoTT Book, we will often make use of pattern matching; for instance, we will write
$\oftyI{(x, \_)}{\sigmaty{a}{A}{B(a)}}$ rather than using the projection notation for
projecting out the first component. There will be some minor notational deviations and
abuses of language, which will be addressed locally, in the relevant sections.

\section{Univalent foundations: the idea}

Starting with the work of Hofmann and Streicher~\cite{hofmann-streicher}, the idea that
the structure of types in intensional type theory is related to homotopy theory had been
brewing in the type theory community. The solidification of this idea started around 2006,
by various independent researchers exploring it from different perspectives. It was around
this time that the concept of univalence emerged. We will not go into the history of
subject.

It was Vladimir Voevodsky who emphasised the possibility of transforming type theory
through insights arising from this line of work~\cite{voevodsky-bernays}. He coined the
term ``univalent foundations'' to refer to such mathematical foundations.

What are the novelties brought by univalent foundations? Mathematical foundations have
historically suffered problems with the notion of equality. In mathematics, superficial
differences between structures are immaterial. For instance, we never want to talk about
the difference between isomorphic graphs. It has therefore been common practice in
mathematics to work with the ``right'' notion of equality between structures:
homeomorphism for topological spaces, isometry for metric spaces, equivalence for
categories, group isomorphism for groups, and so on.

A reasonable expectation from a foundational system for mathematics is that it be able to
validate the common practices in its high-level use. Both set theory and type theory
suffered from this problem, but it is only in the context of type theory that the fact
that this is a problem can be clearly seen. The attempt to implement this informal
practice in type theory gave rise to what is known as ``setoid hell''.

Homotopy type theory, being the first of univalent type theories, was arguably the first
foundational system that somehow validated this practice of working with the ``right''
notion of equality. As remarked by Escardó in his introduction exposition of
HoTT/UF~\cite{escardo-uf-intro}, in univalent type theory, once the type corresponding to
a certain algebraic structure has been written down, the identity type corresponds
\emph{automatically} to the type of isomorphisms for that structure. It is quite
remarkable that this can be achieved by a simple tweak to type theory: first, make sure
that the rich structure of types are not trivialised by the likes of axiom K, and then add
an simple axiom---the univalence axiom---allowing one to prove that
\emph{equivalent types are equal}.

The motivation for this axiom is bolstered by the fact that it also solves many
significant problems of type theory. For instance, it was proven by Voevodsky that
univalence implies function extensionality.

In the remainder of this chapter, we first present the precise technicalities required for
formulating univalence, and then the most salient ones among its consequences that allow
us to use it as a practical foundation.

\section{Equivalence and univalence of types}

At the heart of univalent type theory lies the notion of \emph{type equivalence}. We build
up to it which is given in Definition~\ref{defn:equiv}.

We delineate the class of types that have exactly one inhabitant.
\begin{defn}[Contractible]\label{defn:contr}
  A type $A$ is called contractible if it has exactly one inhabitant:
  \begin{equation*}
    \iscontr{A} \quad\is\quad \sigmaty{c}{A}{\pity{x}{A}{c =_A x}}.
  \end{equation*}
\end{defn}

\begin{defn}[Fiber]\label{defn:fiber}
  Given types $\oftyI{A}{\univ{}_m}$, $\oftyI{B}{\univ{}_n}$, a function $f : A
  \rightarrow B$, and some $\oftyI{y}{B}$, the fiber of $f$ over $y$ is the type of all
  inhabitants of $A$ that are mapped by $f$ to $y$:
  \begin{equation*}
    \fiber{f}{y} \quad\is\quad \sigmaty{x}{A}{f(x) =_B y}.
  \end{equation*}
\end{defn}

The following definition of type equivalence was first formulated by Voevodsky.
\begin{defn}[Equivalence]\label{defn:equiv}
  Given types $\oftyI{A}{\univ{}_m}$, $\oftyI{B}{\univ{}_n}$, a function $f : A \rightarrow B$ is an
  \emph{equivalence} if $\fiber{f}{y}$ is a contractible type for every $\oftyI{y}{B}$:
  \begin{equation*}
    \isequiv{f} \quad\is\quad \pity{y}{B}{\iscontr{\fiber{f}{y}}}.
  \end{equation*}
\end{defn}

We will denote by $\typequiv{A}{B}$ the type of equivalences between types $A$ and $B$.
\begin{defn}[Equivalence of types]
  Given $\oftyI{A}{\univ{}_m}$, $\oftyI{B}{\univ{}_n}$,
  \begin{equation*}
    \typequiv{A}{B} \quad\is\quad \sigmaty{f}{A \rightarrow B}{\isequiv{f}}.
  \end{equation*}
\end{defn}

\begin{defn}[Identity equivalence]\label{defn:id-equiv}
  The identity function on every type $A$ can easily be seen to be an equivalence.
  Therefore there exists a function:
  \begin{equation*}
    \oftyI{\idequivnm}{\pity{A}{\univ{}_n}{\typequiv{A}{A}}}.
  \end{equation*}
\end{defn}

Given two types $\oftyII{A}{B}{\univ{}_n}$, and a proof $\oftyI{p}{A = B}$ that they are
equal, we can clearly prove that they are equivalent.
\begin{defn}\label{defn:id-to-equiv}
  Given any $\oftyII{A}{B}{\univ{}_n}$ with a proof $\oftyI{p}{A = B}$, there exists a
  function:
  \begin{equation*}
    \oftyI{\idtoeqvnm{}}{\pity{A, B}{\univ{}_n}{A = B \rightarrow A \simeq B}}.
  \end{equation*}
\end{defn}

In other words, it is justified intuitively that equality is stronger than equivalence.
The famous univalence axiom states, essentially, that equivalence is as strong as
equality. Formally, this amounts to saying that $\idtoeqvnm{}$ is an equivalence.

\begin{ax}[Univalence]\label{ax:ua}
  The following type has an inhabitant:
  \begin{equation*}
    \pity{A, B}{\univ{}_n}{\isequiv{\idtoeqv{A}{B}}}.
  \end{equation*}
\end{ax}

Although we use the word ``axiom'' here, we do not mean it to have the same sense as the
word ``postulate'' in the context of proof assistants; we merely assume it and investigate
its consequences. It might very well be a theorem, which it indeed is in CTT~\cite{CCHM}.

The univalence axiom immediately gives us the following:
\begin{equation*}
  \pity{A~B}{\univ{}_n}{\typequiv{(A = B)}{(\typequiv{A}{B})}}.
\end{equation*}

The addition of this simple axiom into type theory has some surprising consequences.
Perhaps most importantly, it allows us to \emph{prove} function extensionality.
\begin{defn}[Extensional equality]\label{defn:exteq}
  Given types $\oftyI{A}{\univ{}_m}$ and $\oftyI{B}{\univ{}_n}$, and functions
  $\oftyII{f}{g}{A \rightarrow B}$, $f$ and $g$ are said to be extensionally equal if
  the following type is inhabited:
  \begin{equation*}
    \exteq{f}{g} \quad\is\quad \pity{x}{A}{f(x) = g(x)}.
  \end{equation*}
\end{defn}

\begin{prop}[Function extensionality]\label{prop:funext}
  Two functions are equal whenever they are extensionally equal.
\end{prop}

This was first proven by Voevodsky using the \textsc{Coq} proof assistant.

\section{Homotopy levels}

One of the most interesting observations arising from the association of type theory with
homotopy theory is that we can classify types with respect to the non-trivial homotopy
structure they bear. A space containing no nontrivial homotopy above dimension $n$ is
called a homotopy $n$-type (or said to be of homotopy level $n$).

We then recursively define a predicate expressing that a given type has homotopy level
$n$. The idea is that we increase the dimension by one at each step.
\begin{defn}[Homotopy level]\label{defn:hlevel}
  We will say that the homotopy level of a type $A$ is $\oftyI{n}{\mathbb{N}}$ if
  $\isofhlevel{A}{n}$ as inhabited:
  \begin{align*}
    \isofhlevel{A}{\zero{}} &\quad\is\quad \iscontr{A}\\
    \isofhlevel{A}{\suc{n}} &\quad\is\quad \pity{x~y}{A}{\isofhlevel{x =_A y}{n}}.
  \end{align*}
\end{defn}

The hierarchy of $n$-types is upwards-closed as expressed in the following proposition.
\begin{prop}\label{prop:level-up}
  Given any type $A$, the following type has an inhabitant:
  \begin{equation*}
    \pity{n}{\mathbb{N}}{\isofhlevel{A}{n} \rightarrow \isofhlevel{A}{n+1}}.
  \end{equation*}
\end{prop}

Furthermore, $\sum$ and $\prod$ types respect h-levels.
\begin{prop}\label{prop:is-of-level-pi}
  Given an arbitrary type $\oftyI{A}{\univ{}_m}$ and an $A$-indexed family of $n$-types
  $\oftyI{B}{A \rightarrow \univ{}_o}$, $\pity{x}{A}{B(x)}$ is an $n$-type. In formal
  terms:
  \begin{equation*}
    \left( \pity{x}{A}{\isofhlevel{B(x)}{n}} \right)
      \rightarrow \isofhlevel{\pity{x}{A}{B(x)}}{n}.
  \end{equation*}
\end{prop}

\begin{prop}\label{prop:is-of-level-sigma}
  Given an $n$-type $\oftyI{A}{\univ{}_m}$ and an $A$-indexed family
  $\oftyI{B}{A \rightarrow \univ{}_o}$ of $n$-types, $\sigmaty{x}{A}{B(x)}$ is an $n$-type.
  This is formally expressed by the type below.
  \begin{equation*}
      \isofhlevel{A}{n}
    \rightarrow \left( \pity{x}{A}{\isofhlevel{B(x)}{n}} \right)
    \rightarrow \isofhlevel{\sigmaty{x}{A}{B(x)}}{n}
  \end{equation*}
\end{prop}

\subsection{Propositions}

The homotopy level of one is of special interest: it is the class of types that behave
like logical propositions, in the sense that their proof structure is trivial: they are
inhabited by at most one term. This is precisely the property we desire in those types
that we view as expressing \emph{properties}; we are interested, not in what they are
inhabited by, but in whether they are inhabited or not.

\begin{defn}[Proposition]\label{defn:prop'}
  A type $A$ is a proposition (sometimes disambiguated as an \emph{h-proposition}) if it
  has a homotopy level of one:
  \begin{equation*}
    \isprop{A} \quad\is\quad \isofhlevel{A}{1}.
  \end{equation*}
\end{defn}

An equivalent and much more intuitive way of expressing propositionality is the following.
\begin{defn}[Proposition (official)]\label{defn:hprop}
  \begin{equation*}
    \isprop{A} \quad\is\quad \pity{x~y}{A}{x =_A y}.
  \end{equation*}
\end{defn}
\begin{prop}
  Definitions \ref{defn:prop'} and \ref{defn:hprop} are equivalent.
\end{prop}
Due to this equivalence, we will use definitions \ref{defn:prop'} and \ref{defn:hprop}
interchangeably. Which definition we are referring to will be clear in context.

We collect propositional types at level $n$ in the type $\hprop{}_n$.
\begin{defn}[$\hprop{}$]\label{defn:omega}
  $\hprop{}_n$ is the type of all propositional types at universe $n$:
  \begin{equation*}
    \hprop{}_n \quad\is\quad \sigmaty{A}{\univ{}_n}{\isprop{A}}.
  \end{equation*}
\end{defn}

When asserting that a proposition $\oftyI{A}{\hprop{}_n}$ is inhabited, we have to project
out the first component to be completely precise. We will engage in the excusable
notational abuse of denoting this projection by $A$ itself. The \veragda{} formalisation
uses the notational convention of the \texttt{cubical}~\cite{agda-cubical} library in
which this projection is denoted $\mathtt{[} A \mathtt{]}$.

Notice that $\hprop{}$ itself is always an h-set.
\begin{prop}\label{prop:hprop-set}
  $\hprop{}$ is an h-set.
\end{prop}

Once we introduce this delineation of the class of propositional types, we have to make
sure that types that are thought of as properties are actually propositional types. This
is usually easy to do, that is, most types that are expected to behave like propositions
behave naturally like propositions, so it suffices to prove this fact. However, there are
cases when they actually \emph{are not} propositional. A substantial component of the work
presented in this thesis is devoted to the problem of forcing certain types to behave
propositionally.

Now, let us state some simple facts about the class of propositional types. Observe the
two corollaries, of propositions \ref{prop:is-of-level-pi} and
\ref{prop:is-of-level-sigma} respectively.

\begin{prop}\label{prop:pi-prop}
  Given $\oftyI{A}{\univ{}_m}$, $\oftyI{B}{A \rightarrow \univ{}_n}$, the type $\pity{x}{A}{B(x)}$
  is a proposition whenever $B(x)$ is proposition every $\oftyI{x}{A}$.
\end{prop}
\begin{proof}
  Direct application of Proposition~\ref{prop:is-of-level-pi} with $n \is 1$.
\end{proof}

\begin{prop}\label{prop:sigma-prop}
  Given types $\oftyI{A}{\univ{}_m}$ and $\oftyI{B}{A \rightarrow \univ{}_n}$, if $A$ is a
  proposition and $B$ is a family of propositions, then $\sigmaty{x}{A}{B}$ is a
  proposition.
\end{prop}
\begin{proof}
  Direct application of Proposition~\ref{prop:is-of-level-sigma} with $n \is 1$.
\end{proof}

The type expressing that a given type $A$ is a proposition, is itself a proposition.
\begin{prop}
  Given $\oftyI{A}{\univ{}_n}$, the type $\isprop{A}$ is propositional.
\end{prop}

Notice also the following fact.
\begin{prop}\label{prop:to-subtype}
  Given some type $A$, and a family of propositions $\oftyI{B}{A \rightarrow \hprop{}}$, to show the
  equality of two inhabitants of $\oftyII{(x, p)}{(y, q)}{\sigmaty{a}{A}{B(a)}}$, it
  suffices to show the equality of $x$ and $y$.
\end{prop}

As we view propositional types as embodying logical propositions, it is natural to
expect that the right notion of equivalence between them is logical equivalence.
\begin{defn}\label{defn:iff}
  Types $\oftyI{A}{\univ{}_m}$ and $\oftyI{B}{\univ{}_n}$ are logically equivalent
  (denoted $\logequiv{A}{B}$) if the following type is inhabited:
  \begin{equation*}
    \logequiv{A}{B} \quad\is\quad (A \rightarrow B) \times (B \rightarrow A).
  \end{equation*}
\end{defn}
Indeed, it is sufficient in univalent type theory to show logical equivalence to establish
the equivalence of two propositional types.
\begin{prop}\label{prop:iff-equiv}
  Given propositions $\oftyI{P}{\univ{}_m}$, $\oftyI{Q}{\univ{}_n}$, if $\logequiv{P}{Q}$
  then $\typequiv{A}{B}$.
\end{prop}

\subsection{Sets}

The other homotopy class of interest is the class of types whose proof structures are not
trivial but the proof structures of their types of equality proofs are trivial. Put more
simply, inhabitants of a set are equal to each other in
\emph{at most one way}.
\begin{defn}[Set]\label{defn:hset}
  A type $A$ is a set if its homotopy level is two:
  \begin{equation*}
    \isset{A} \quad\is\quad \isofhlevel{A}{2}.
  \end{equation*}
\end{defn}

The structures we present in chapters \ref{chap:frames} and \ref{chap:formal-topo} have
underlying partially ordered \emph{sets}. When implementing these in univalent type
theory, they must be required to be h-sets. A more accurate name for a ``poset'' whose
carrier set bears higher dimensional homotopy structure would be \emph{$\infty$-poset}.

Observe the following corollary of Proposition~\ref{prop:level-up}.
\begin{prop}\label{prop:prop-is-set}
  Every proposition is a set.
\end{prop}

As we have done for the case of h-propositions, we consider the special cases
of propositions \ref{prop:is-of-level-pi} and \ref{prop:is-of-level-sigma} in the
h-set case.

\begin{prop}\label{prop:pi-set}
  Given $\oftyI{A}{\univ{}_m}$, $\oftyI{B}{A \rightarrow \univ{}_n}$, the type $\pity{x}{A}{B(x)}$
  is a set whenever $B(x)$ is a set for every $\oftyI{x}{A}$.
\end{prop}

\begin{prop}\label{prop:sigma-set}
  Given types $\oftyI{A}{\univ{}_m}$ and $\oftyI{B}{\univ{}_n}$, if $A$ is an set and
  $B(a)$ is an set for every $\oftyI{a}{A}$, then $\sigmaty{x}{A}{B}$ is an set.
\end{prop}

Notice also that the type expressing a given a type is a set is a proposition.
\begin{prop}\label{prop:set-prop}
  Given any type $A$, the type $\isset{A}$ is a proposition.
\end{prop}

\section{Powersets}\label{sec:pow}

Given a type $A$, we would like to talk about its powerset: the type of \emph{properties}
the inhabitants of $A$ might have. This is nothing but the type $A \rightarrow \hprop{}$. It is here
that the property-structure distinction starts to become visible: in non-univalent type
theory one would simply use $A \rightarrow \univ{}$ for this purpose.

Using the powerset, we represent subsets of inhabitants of a type. This is just one
representation; we will present the other common approach in Section~\ref{sec:fam}.

\begin{defn}\label{defn:pow}
  Given a type $\oftyI{A}{\univ{}_n}$, the \emph{powerset} of $A$ is the type of all
  predicates on $A$:
  \begin{equation*}
    \pow{A} \quad\is\quad A \rightarrow \hprop{}_n.
  \end{equation*}
  We introduce a bit of syntactic sugar and write membership in a subset as:
  \begin{equation*}
    \mempow{x}{U} \is U(x).
  \end{equation*}
\end{defn}

Our use of the word ``set'' in ``powerset'' is justified by the following proposition.
\begin{prop}\label{prop:pow-set}
  Given \emph{any} type $A$, $\pow{A}$ is an h-set.
\end{prop}
\begin{proof}
  By Proposition~\ref{prop:pi-set}, suffices to show that the codomain, $\hprop{}$, is
  a set. This is given by Proposition~\ref{prop:hprop-set}.
\end{proof}

Powersets are ordered under the usual inclusion order.
\begin{defn}\label{defn:inclusion}
  Given a type $\oftyI{A}{\univ{}_n}$ and subsets $\oftyII{U}{V}{\pow{A}}$,
  $U$ is a subset of $B$ if the following type is inhabited:
  \begin{equation*}
    \subsetof{U}{V} \quad\is\quad \pity{x}{A}{x \in U \rightarrow x \in V}.
  \end{equation*}
\end{defn}

\begin{defn}[Full subset]\label{defn:entire-subset}
  Given a type $\oftyI{A}{\univ{}_n}$, the subset containing all inhabitants of $A$ is
  defined as the constant function $\lambda\_.~\unitty{}_n$.
\end{defn}

Notice that, by the definition of $\pownm{}$, the type has to live in the same universe as
$A$. It is for this reason that we generalise the $\unitty{}$ type to take as an argument
the universe level we would like it to inhabit and inhabits that universe.

\begin{defn}\label{defn:intersection}
  Given a type $\oftyI{A}{\univ{}_n}$ and subsets $\oftyII{U}{V}{\pow{A}}$, the subset
  delineating those elements that are in \emph{both} of $U$ and $V$ is defined as:
  \begin{align*}
    \_\cap\_  \quad&:\quad   \pow{A} \rightarrow \pow{A} \rightarrow \pow{A} \\
    U \cap V  \quad&\is\quad \lambda x.~ x \in U \times x \in V  .
  \end{align*}
  We note that $x \in U \cap V$ is propositional by the propositionality of $x \in U$ and $x \in V$
  combined via Proposition~\ref{prop:sigma-prop}.
\end{defn}

\section{Families}\label{sec:fam}

In type theory, we have two notions of ``subset of a type''. One of these is the powerset
as we presented in Sec.~\ref{sec:pow}. We now briefly summarise the other approach in
which we view a subset of a type $A$ as an $A$-valued function (on some domain).

\begin{defn}[Family]\label{defn:fam}
  Given a type $A$, an $I$-indexed family of inhabitants of $A$ is simply a function:
  $I \rightarrow A$. We collect the type of all families on $A$ in the following type:
  \begin{equation*}
    \sub{o}{A} \quad\is\quad \sigmaty{I}{\univ{}_o}{I \rightarrow A}.
  \end{equation*}
  Notice that this is parameterised by a level $o$, being the level of the index type.
  Given a family $\oftyI{U \equiv (I, f)}{\sub{o}{A}}$, we will denote the evaluation of it at
  $\oftyI{i}{I}$ as $U_i$.
\end{defn}

\paragraph*{Notational clarification.} An inhabitant of $\sub{o}{A}$ has the form
$(I, f)$ as defined in Defn.~\ref{defn:fam}. However, we will use some more suggestive
notation for pairs of this form. It is quite convenient to be able to talk about a family
as though it were a concrete set, so we will use the notation $\{ x_i ~|~ i \in I \}$ as a
substitute for ``$I$-indexed family whose $i$th projection is denoted $x_i$''. Furthermore,
we will talk quite often about join operators $\oftyI{\bigvee\_}{\sub{o}{A} \rightarrow A}$. Instead of
writing, $\bigvee (I, \lambda i.~e(i))$ for the application of a join operator to a family, we will
use the more familiar notation of
\begin{equation}\label{eqn:join-syntax}
  \bigvee_i e
\end{equation}
What is meant by such notational sugar is expected to be obvious to the reader.

In the \veragda{} formalisation, we use similar notational conventions. For instance, the
syntax we have exemplified in (\ref{eqn:join-syntax}) is implemented in the
\modname{JoinSyntax} submodule of the \modname{Frame} module.
\begin{code}%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{JoinSyntax}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaGeneralizable{ℓ₀}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ℓ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{Level}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{join}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Fam}\AgdaSpace{}%
\AgdaBound{ℓ₂}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{join-of}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaBound{ℓ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{I}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\>[2]\AgdaFunction{join-of}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{I}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{I}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{join}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{I}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaKeyword{syntax}\AgdaSpace{}%
\AgdaFunction{join-of}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{e}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⋁⟨}\AgdaSpace{}%
\AgdaBound{i}\AgdaSpace{}%
\AgdaFunction{⟩}\AgdaSpace{}%
\AgdaBound{e}\<%
\end{code}

The bracketed index $\mathtt{⟨~i~⟩}$ is intended to be a plain text approximation of
subscripting.

\begin{defn}[Family membership]\label{defn:fam-mem}
  Given a type $A$, some $\oftyI{x}{A}$, and a family $U \equiv (I, f)$, we say
  that $x$ is a member of $U$ if the fiber of $f$ over $x$ is inhabited:
  \begin{equation*}
    \memfam{x}{U} \quad\is\quad \fiber{f}{x}.
  \end{equation*}
\end{defn}

\begin{defn}[Image over a family]\label{defn:fam-img}
  Given a type $A$, some family $U \equiv (I, f)$, and a function $\oftyI{g}{A \rightarrow B}$, the
  image of $g$ over $U$ is nothing but the family $(I, g \circ f)$.
  We will denote this $\img{g}{U}$ or $\setof{ g(f(i)) ~|~ \oftyI{i}{I} }$.
\end{defn}

\paragraph*{Remark on Agda notation.}
Again, we follow a similar notational sugaring in the \veragda{} formalisation. As the
curly bracket symbols, \texttt{\{} and \texttt{\}}, are not available in \veragda{}, we
approximate them as $\texttt{\textlquill}$ and $\texttt{\textrquill}$ for the comprehension notation. One
instance of such a syntax declaration can be found in the \modname{Family} module.

\begin{code}%
\>[0]\AgdaFunction{img}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaGeneralizable{ℓ₀}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Type}\AgdaSpace{}%
\AgdaGeneralizable{ℓ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{g}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{Y}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ℱ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Fam}\AgdaSpace{}%
\AgdaGeneralizable{ℓ₂}\AgdaSpace{}%
\AgdaBound{X}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Sub}\AgdaSpace{}%
\AgdaGeneralizable{ℓ₂}\AgdaSpace{}%
\AgdaBound{Y}\<%
\\
\>[0]\AgdaFunction{img}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaBound{(I , f)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{I}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{g}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{syntax}\AgdaSpace{}%
\AgdaFunction{img}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{e}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{ℱ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⁅}\AgdaSpace{}%
\AgdaBound{e}\AgdaSpace{}%
\AgdaFunction{∣}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaFunction{ε}\AgdaSpace{}%
\AgdaBound{ℱ}\AgdaSpace{}%
\AgdaFunction{⁆}\<%
\end{code}

Given a powerset $U$ on some type $A$, we can represent subset $U$ represents as a family
in a very simple way as given below.
\begin{defn}[Familification of a powerset]
  Let $A$ be a type and $\oftyI{U}{\pow{A}}$. The family associated with $U$ is
  the pair $(I, f)$ where
  \begin{align*}
    I \quad&\is\quad \sigmaty{x}{A}{U(x)} \\
    f \quad&\is\quad \mathsf{pr}_1        .
  \end{align*}
\end{defn}

As what representation we are working with will be clear to the reader from the context,
we will engage in a form notational abuse and will not explicitly denote that we are
working with the familification of a powerset. In the \veragda{} formalisation, this is
denoted $\AgdaFunction{⟪} U \AgdaFunction{⟫}$.

\section{Higher Inductive Types (HITs)}

In ordinary type theory, the inductive definition of a type amounts to a specification of
its points. In univalent type theory, we are working not just with $2$-types but with
arbitrary $n$-types. Therefore, we accordingly generalise our mechanism for the inductive
specification of types by generalising points to $n$-paths. In other words, we add the
means to define a type not just by specifying its points, but also the paths between the
points, paths between those paths, and then paths between those and so on. Such an
inductive type is called a \emph{higher inductive type} (HIT for short).

Let us give an example of what an HIT definition might look like. The usual $\unitty{}$
type would be inductively defined by the specification of a single constructor:
\begin{equation*}
  \begin{prooftree}
    \infer0[$\rulename{tt}$.]{\unitty{}}
  \end{prooftree}
\end{equation*}
whose only equality is the trivial one: $\oftyI{\mathsf{refl}_\star}{\star =_{\unitty{}} \star}$.

Using HITs, we can add, for instance, a non-trivial equality of $\star$ to itself. The
resulting type is called the $\mathsf{Circle}$.
\begin{equation*}
  \begin{prooftree}
    \infer0[$\rulename{base}$]{\mathsf{Circle}}
  \end{prooftree}
  \hspace{2em}
  \begin{prooftree}
    \infer0[$\rulename{loop}$]{{\mathsf{base} = \mathsf{base}}}
  \end{prooftree}
\end{equation*}

\todo{talk about the induction principles.}

HITs turn out to be immensely useful and in fact we will explain later that they are used
in a crucial way in this thesis: the main construction of Chapter~\ref{chap:formal-topo}
would not have been possible without them (i.e., it is not known to us how it would have
been possible without them).

\section{Truncation}

A particular HIT of interest will be the \emph{propositional truncation} type. This will
allow us to \emph{forget} the proof structure of a type, or in other words, force a
non-propositional type to be propositional by collapsing its proof structure.

This turns out to be useful as it gives us a way of turning structure into property.
Consider for instance two propositions $\oftyII{P}{Q}{\Omega_n}$. We would like to be able to
express their logical disjunction, $P + Q$, and we would also like it to be a proposition
itself. It will clearly not be propositional due to the fundamental, proof-relevant nature
of type theory: the inhabitant will contain the information of which one of $P$ or $Q$ it
comes from. For this to become propositional, we have to \emph{forget} this information;
propositional truncation allows us to do precisely this.

We now give the definition of propositional truncation as an HIT.

\begin{defn}[Propositional truncation]\label{defn:truncation}
  Given a type $A$, its propositional truncation $\trunc{A}$ is a HIT given by
  one constructor, $\rulename{inj}$, and one path, $\rulename{trsquash}$.
  \begin{equation*}
    \begin{prooftree}
      \hypo{\oftyI{x}{A}}
      \infer1[$\rulename{inj}$]{\oftyI{x}{\trunc{A}}}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\oftyI{x}{\trunc{A}}}
      \hypo{\oftyI{y}{\trunc{A}}}
      \infer2[$\rulename{trsquash}$]{x = y}
    \end{prooftree}
  \end{equation*}
  The recursion principle for propositional truncation is the following: given any two
  types $A$ and $B$, to show $\trunc{A} \rightarrow B$ it suffices to show $\isprop{B}$ and $A \rightarrow B$.
  Formally,
  \begin{equation*}
    \isprop{B} \rightarrow (A \rightarrow B) \rightarrow \trunc{A} \rightarrow B.
  \end{equation*}
\end{defn}

Observe that this corresponds to the intuitive distinction between \emph{property} and
\emph{structure}: we are allowed to use the inhabitant of a propositionally truncated type
only if it will be used in the proof of another property i.e., only in a context where the
structure will not become exposed.

This definition of propositional truncation as an HIT brings us to the end of this
chapter. With all the foundational notions we have defined, we are now ready to carry out
an investigation of formal topology in univalent foundations.
